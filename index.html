<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png" />
    <link rel="stylesheet" href="css/common.css" />
    <title>Fungs Design AR</title>
    <style>
      #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      #resetButton {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        pointer-events: auto; /* Ensure the button is interactive */
      }

      header {
        position: absolute;
        bottom: 50%;
        left: 50%;
        transform: translateX(-50%);
        /*         padding: 10px 20px; */
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        pointer-events: auto; /* Ensure the button is interactive */
      }
    </style>
  </head>
  <body>
    <header></header>

    <div id="overlay">
      <button
        id="resetButton"
        style="background: none; border: none; padding: 0; cursor: pointer"
      >
        <img
          src="media/textures/phone_AR_C_TW_Recenter.png"
          alt="Reset Anchors"
          style="width: 50px; height: 50px"
        />
      </button>
    </div>

    <!-- <div id="overlay">
      <button id="infoButton" style="background: none; border: none; padding: 0; cursor: pointer;">
        <img src="media/textures/phone_AR_C_TW_.png" alt="Info Anchors" style="width: 50px; height: 50px;">
      </button>
    </div> -->

    <script type="module">
      import { WebXRButton } from "./js/util/webxr-button.js";
      import { Scene } from "./js/render/scenes/scene.js";
      import {
        Renderer,
        createWebGLContext,
      } from "./js/render/core/renderer.js";
      import { Node } from "./js/render/core/node.js";
      import { Gltf2Node } from "./js/render/nodes/gltf2.js";
      import { DropShadowNode } from "./js/render/nodes/drop-shadow.js";
      import { vec3 } from "./js/render/math/gl-matrix.js";
      import { Ray } from "./js/render/math/ray.js";

      // XR globals.
      let xrButton = null;
      let xrSession = null;
      let xrRefSpace = null;
      let xrViewerSpace = null;
      let xrHitTestSource = null;

      // WebGL scene globals.
      let gl = null;
      let renderer = null;
      let scene = new Scene();
      scene.enableStats(false);

      let arObject = new Node();
      arObject.visible = false;
      scene.addNode(arObject);

      let flower = new Gltf2Node({
        url: "media/gltf/Power Drill/PowerDrill_v00010001.gltf",
      });
      flower.scale = [0.001, 0.001, 0.001];
      arObject.addNode(flower);

      let reticle = new Gltf2Node({ url: "media/gltf/reticle/reticle.gltf" });
      reticle.visible = false;
      scene.addNode(reticle);
      let reticleHitTestResult = null;

      // Having a really simple drop shadow underneath an object helps ground
      // it in the world without adding much complexity.
      let shadow = new DropShadowNode();
      vec3.set(shadow.scale, 0.15, 0.15, 0.15);
      arObject.addNode(shadow);

      const MAX_FLOWERS = 30;
      let flowers = [];

      // Ensure the background is transparent for AR.
      scene.clear = false;

      const anchoredObjects = [];

      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT  AR",
        });
        document.querySelector("header").appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr
            .isSessionSupported("immersive-ar", {
              requiredFeatures: ["dom-overlay"],
            })
            .then((supported) => {
              xrButton.enabled = supported;
            });
        }

        document
          .getElementById("resetButton")
          .addEventListener("click", resetAnchors);
      }

      function onRequestSession() {
        return navigator.xr
          .requestSession("immersive-ar", {
            requiredFeatures: ["local", "hit-test", "anchors", "dom-overlay"],
            domOverlay: { root: document.getElementById("overlay") },
          })
          .then((session) => {
            xrSession = session;
            xrButton.setSession(session);
            onSessionStarted(session);
          });
      }

      function onSessionStarted(session) {
        session.addEventListener("end", onSessionEnded);
        session.addEventListener("select", onSelect);

        if (!gl) {
          gl = createWebGLContext({
            xrCompatible: true,
          });

          renderer = new Renderer(gl);

          scene.setRenderer(renderer);
        }

        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });

        session.requestReferenceSpace("viewer").then((refSpace) => {
          xrViewerSpace = refSpace;
          session
            .requestHitTestSource({ space: xrViewerSpace })
            .then((hitTestSource) => {
              xrHitTestSource = hitTestSource;
            });
        });

        session.requestReferenceSpace("local").then((refSpace) => {
          xrRefSpace = refSpace;

          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onEndSession(session) {
        anchoredObjects.forEach((obj) => obj.anchor.delete());
        anchoredObjects.length = 0;
        if (xrHitTestSource) {
          xrHitTestSource.cancel();
          xrHitTestSource = null;
        }
        session.end();
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);
        xrSession = null;
      }

      const MAX_ANCHORED_OBJECTS = 30;

      function addAnchoredObjectsToScene(anchor) {
        let flower = new Gltf2Node({
          url: "media/gltf/powerdrill/Power Drill.gltf",
        });
        scene.addNode(flower);
        anchoredObjects.push({
          anchoredObject: flower,
          anchor: anchor,
        });

        if (anchoredObjects.length > MAX_ANCHORED_OBJECTS) {
          let objectToRemove = anchoredObjects.shift();
          scene.removeNode(objectToRemove.anchoredObject);
          objectToRemove.anchor.delete();
        }
      }

      function onSelect(event) {
        if (reticle.visible) {
          reticleHitTestResult.createAnchor().then(
            (anchor) => {
              addAnchoredObjectsToScene(anchor);
            },
            (error) => {
              console.error("Could not create anchor: " + error);
            }
          );
        }
      }

      function onXRFrame(t, frame) {
        if (!xrSession) {
          return;
        }

        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);

        reticle.visible = false;

        if (xrHitTestSource && pose) {
          let hitTestResults = frame.getHitTestResults(xrHitTestSource);
          if (hitTestResults.length > 0) {
            let pose = hitTestResults[0].getPose(xrRefSpace);
            reticle.visible = true;
            reticle.matrix = pose.transform.matrix;
            reticleHitTestResult = hitTestResults[0];
          }
        }

        for (const { anchoredObject, anchor } of anchoredObjects) {
          if (!frame.trackedAnchors.has(anchor)) {
            continue;
          }
          const anchorPose = frame.getPose(anchor.anchorSpace, xrRefSpace);
          anchoredObject.matrix = anchorPose.transform.matrix;
        }

        scene.startFrame();

        session.requestAnimationFrame(onXRFrame);

        scene.drawXRFrame(frame, pose);

        scene.endFrame();
      }

      function resetAnchors() {
        // anchoredObjects.forEach(obj => obj.anchor.delete());
        anchoredObjects.forEach((obj) => {
          scene.removeNode(obj.anchoredObject); // Remove the node from the scene
          obj.anchor.delete(); // Delete the XRAnchor
        });
        anchoredObjects.length = 0;
        console.log("remove ArObject");
      }

      // Start the XR application.
      initXR();
    </script>
  </body>
</html>
